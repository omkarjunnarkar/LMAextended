#include<iostream>
#include<Eigen/Dense>
#include<iomanip>
#include<fstream>
#include<math.h>
#include<vector>
#include"src/rapidcsv.h"
#include"myfunctions.h"

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------*/

using namespace std;
using namespace Eigen;
using namespace rapidcsv;

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------*/

void main() {
	
	//Reading data from the csv files generated by python script 'otpt.py'

	Document dx("xdata.csv");
	/*Document dz("zdata.csv");
	Document dp("pdata.csv");*/
	Document dy("y_measured.csv");
	
	vector<double> xcol = dx.GetColumn<double>(0);
	/*vector<double> zcol = dz.GetColumn<double>(0);
	vector<double> pcol = dp.GetColumn<double>(0);*/
	vector<double> ycol = dy.GetColumn<double>(0);

	//Defining the Arrays containing the variable data points and measured values

	int data_size = ycol.size();
	MatrixXd xdata(ycol.size(), 1);
	/*MatrixXd zdata(ycol.size(), 1);
	MatrixXd pdata(pcol.size(), 1);*/
	MatrixXd y_measured(ycol.size(), 1);

	for (int u = 0; u < data_size ; u++) {
		xdata(u, 0) = xcol[u];
		/*zdata(u, 0) = zcol[u];
		pdata(u, 0) = pcol[u];*/
		y_measured(u, 0) = ycol[u];
	}
	
	//Standard Deviation of the measured data

	//double stddev = sqrt((y_measured.array() - y_measured.mean()).square().sum() / (y_measured.size() - 1));
	double stddev = 1;
	cout << "STD DEV = " << stddev << endl;

	MatrixXd IdentityMat = MatrixXd::Identity(y_measured.rows(), y_measured.rows());
	MatrixXd W = (1 / pow(stddev,2)) * IdentityMat;		//Diagonal Matrix with Variance values at the diagonals

	MatrixXd parameters{
		{1.0,1.0, 2.0}  //Initial Guess for parameters
	};

	MatrixXd init{
		{1e-8,1e-8, 1e-8}	//Initial deflection for parameters(to find Jacobian Matrix using finite difference scheme)
	};

	parameters = parameters.reshaped(parameters.cols(), 1);
	init = init.reshaped(parameters.cols(), 1);

	//Calling the Levenberg-Marquardt Algorithm from 'myfunctions.cpp'

	MatrixXd final_parameters = levenberg_fit(W,y_measured, xdata, init, parameters, 1e3);
	cout << final_parameters << endl;

}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------*/